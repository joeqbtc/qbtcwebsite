<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered Fluid Image Pixelation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            cursor: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .ai-panel {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
         /* Simple spinner for loading states */
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen">

    <canvas id="interactive-canvas"></canvas>
    
    <!-- The image to be used. It's hidden because we'll draw it on the canvas. -->
    <img id="source-image" src="https://placehold.co/800x600/2E2A3A/FFFFFF?text=A+New+Beginning" class="hidden" alt="Placeholder image" crossorigin="anonymous">

    <!-- AI Control Panel -->
    <div class="absolute bottom-4 left-4 right-4 md:left-auto md:right-4 md:max-w-md w-auto z-20">
        <div class="ai-panel bg-gray-800 bg-opacity-50 border border-gray-700 rounded-xl p-4 shadow-2xl">
            <h2 class="text-lg font-bold mb-3 text-center">✨ Gemini AI Controls</h2>
            
            <!-- Image Generation -->
            <div class="mb-4">
                <label for="prompt-input" class="block text-sm font-medium mb-1 text-gray-300">Generate a new image:</label>
                <div class="flex items-center gap-2">
                    <input type="text" id="prompt-input" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5" placeholder="e.g., a futuristic city at sunset">
                    <button id="generate-btn" class="text-white bg-blue-600 hover:bg-blue-700 focus:ring-4 focus:outline-none focus:ring-blue-800 font-medium rounded-lg text-sm px-4 py-2.5 text-center">
                        Generate
                    </button>
                </div>
            </div>

            <!-- Image Description -->
            <div>
                 <button id="describe-btn" class="w-full text-white bg-green-600 hover:bg-green-700 focus:ring-4 focus:outline-none focus:ring-green-800 font-medium rounded-lg text-sm px-5 py-2.5 text-center mb-2">
                    ✨ Describe Current Image
                </button>
                <textarea id="description-output" rows="4" class="bg-gray-900/50 border border-gray-600 text-gray-300 text-sm rounded-lg block w-full p-2.5" placeholder="AI description will appear here..." readonly></textarea>
            </div>
             <!-- Loading/Error Display -->
            <div id="status-display" class="mt-3 text-center text-sm h-5"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('interactive-canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const image = document.getElementById('source-image');

            // AI Panel Elements
            const generateBtn = document.getElementById('generate-btn');
            const describeBtn = document.getElementById('describe-btn');
            const promptInput = document.getElementById('prompt-input');
            const descriptionOutput = document.getElementById('description-output');
            const statusDisplay = document.getElementById('status-display');

            // --- Configuration ---
            const PARTICLE_SIZE = 5;
            const MOUSE_RADIUS = 60;
            const PUSH_STRENGTH = 0.8;
            const RETURN_SPEED = 0.04;
            const DAMPING = 0.95;

            let particles = [];
            let mouse = { x: -Infinity, y: -Infinity };
            let animationFrameId = null;

            class Particle {
                constructor(x, y, color) {
                    this.x = x; this.y = y;
                    this.originX = x; this.originY = y;
                    this.color = color;
                    this.vx = 0; this.vy = 0;
                }

                draw() {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, PARTICLE_SIZE, PARTICLE_SIZE);
                }

                update() {
                    const dx = this.x - mouse.x;
                    const dy = this.y - mouse.y;
                    // FIX: Corrected distance calculation (was dy*dy, now dy*dy)
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < MOUSE_RADIUS) {
                        const force = (MOUSE_RADIUS - distance) / MOUSE_RADIUS;
                        const angle = Math.atan2(dy, dx);
                        this.vx += force * Math.cos(angle) * PUSH_STRENGTH;
                        this.vy += force * Math.sin(angle) * PUSH_STRENGTH;
                    }

                    this.vx += (this.originX - this.x) * RETURN_SPEED;
                    this.vy += (this.originY - this.y) * RETURN_SPEED;
                    this.vx *= DAMPING;
                    this.vy *= DAMPING;
                    this.x += this.vx;
                    this.y += this.vy;
                }
            }
            
            function init() {
                if (!image.complete || image.naturalWidth === 0) return;

                const aspectRatio = image.naturalWidth / image.naturalHeight;
                const canvasWidth = Math.min(window.innerWidth * 0.9, image.naturalWidth, 1000);
                const canvasHeight = canvasWidth / aspectRatio;

                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                particles = [];
                ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
                
                try {
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    for (let y = 0; y < canvas.height; y += PARTICLE_SIZE) {
                        for (let x = 0; x < canvas.width; x += PARTICLE_SIZE) {
                            const index = (y * imageData.width + x) * 4;
                            if (imageData.data[index + 3] > 128) {
                               const color = `rgb(${imageData.data[index]},${imageData.data[index+1]},${imageData.data[index+2]})`;
                               particles.push(new Particle(x, y, color));
                            }
                        }
                    }
                } catch(e) {
                    console.error("Error getting image data:", e);
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = "white";
                    ctx.textAlign = "center";
                    ctx.font = "16px Inter";
                    ctx.fillText("Could not load image. Cross-origin restrictions may apply.", canvas.width / 2, canvas.height / 2);
                    return;
                }
               
                if(!animationFrameId) animate();
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (const particle of particles) {
                    particle.update();
                    particle.draw();
                }
                drawMouseFollower();
                animationFrameId = requestAnimationFrame(animate);
            }

            function drawMouseFollower() {
                if(mouse.x < 0 || mouse.y < 0) return;
                ctx.beginPath();
                ctx.arc(mouse.x, mouse.y, MOUSE_RADIUS / 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fill();
            }
            
            function setStatus(text, isError = false, isLoading = false) {
                statusDisplay.innerHTML = ''; // Clear previous content
                if (isLoading) {
                    const loader = document.createElement('div');
                    loader.className = 'loader mx-auto';
                    statusDisplay.appendChild(loader);
                } else {
                    statusDisplay.textContent = text;
                }
                statusDisplay.style.color = isError ? '#f87171' : '#9ca3af';
            }

            // --- Gemini API Functions ---

            /**
             * Generates a new image using Imagen model.
             */
            async function handleGenerateImage() {
                const prompt = promptInput.value;
                if (!prompt) {
                    setStatus("Please enter a prompt.", true);
                    return;
                }
                setStatus("Generating image...", false, true);
                generateBtn.disabled = true;
                describeBtn.disabled = true;

                try {
                    const payload = { instances: [{ prompt }], parameters: { "sampleCount": 1 } };
                    const apiKey = ""; // Leave empty, handled by environment
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
                    
                    const result = await response.json();

                    if (result.predictions && result.predictions[0]?.bytesBase64Encoded) {
                        image.src = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                        // The image's onload event will trigger init() automatically
                        setStatus("New image loaded!", false);
                        descriptionOutput.value = ""; // Clear old description
                    } else {
                        throw new Error("No image data in API response.");
                    }
                } catch (error) {
                    console.error("Image generation error:", error);
                    setStatus(error.message, true);
                } finally {
                    generateBtn.disabled = false;
                    describeBtn.disabled = false;
                }
            }

            /**
             * Generates a description for the current canvas image.
             */
            async function handleDescribeImage() {
                setStatus("Analyzing image...", false, true);
                generateBtn.disabled = true;
                describeBtn.disabled = true;
                descriptionOutput.value = "";

                try {
                    const base64ImageData = canvas.toDataURL('image/jpeg').split(',')[1];
                    
                    const payload = {
                        contents: [{
                            parts: [
                                { text: "Describe this image in a short, artistic paragraph. Focus on the mood and feeling." },
                                { inlineData: { mimeType: "image/jpeg", data: base64ImageData } }
                            ]
                        }]
                    };
                    const apiKey = ""; // Leave empty, handled by environment
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) throw new Error(`API Error: ${response.statusText}`);

                    const result = await response.json();
                    
                    if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                        const text = result.candidates[0].content.parts[0].text;
                        descriptionOutput.value = text;
                        setStatus("Description complete.", false);
                    } else {
                        throw new Error("Could not parse description from API response.");
                    }
                } catch (error) {
                    console.error("Image description error:", error);
                    setStatus(error.message, true);
                } finally {
                    generateBtn.disabled = false;
                    describeBtn.disabled = false;
                }
            }

            // --- Event Listeners ---
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = e.clientX - rect.left;
                mouse.y = e.clientY - rect.top;
            });

            canvas.addEventListener('mouseleave', () => { mouse.x = -Infinity; mouse.y = -Infinity; });

            image.onload = () => {
                // Cancel any pending animation frame to prevent multiple loops
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                init();
            };
            
            if (image.complete && image.naturalWidth > 0) image.onload();

            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                    init();
                }, 250);
            });

            generateBtn.addEventListener('click', handleGenerateImage);
            describeBtn.addEventListener('click', handleDescribeImage);
            promptInput.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') handleGenerateImage();
            });
        });
    </script>
</body>
</html>
