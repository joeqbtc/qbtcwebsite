<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Orbiting‑Bitcoin Widget</title>
<style>
    /* Full‑bleed but can be embedded in any container */
    html,body,#scene {width:100%;height:100%;margin:0;overflow:hidden;background:#000;}
    /* Fallback for browsers with WebGL disabled */
    .no-webgl {display:flex;align-items:center;justify-content:center;color:#fff;font-family:sans-serif}
</style>
</head>
<body>
<noscript><div class="no-webgl">WebGL is required to view this content.</div></noscript>
<canvas id="scene"></canvas>

<!-- Three.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js"></script>

<script>
(function () {
    // Detect WebGL support
    if (!window.WebGLRenderingContext) {
        document.body.innerHTML = '<div class="no-webgl">WebGL is required to view this content.</div>';
        return;
    }

    /** ---------- 1. Basic Three‑js setup ---------- **/
    const canvas   = document.getElementById('scene');
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    const scene    = new THREE.Scene();
    const camera   = new THREE.PerspectiveCamera(35, 1, 0.1, 100);
    camera.position.z = 4;

    /** ---------- 2. Lighting ---------- **/
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffa040, 0.8);
    dirLight.position.set(2, 2, 2);
    scene.add(dirLight);

    /** ---------- 3. Textures & Materials ---------- **/
    // Convert your PNG to Base‑64 once, keep bundle self‑contained
    // (Replace ... with the full data‑URL if you optimise/compress the asset)
    const BITMAP = 'data:image/png;base64,REPLACE_WITH_YOUR_BASE64';
    const loader = new THREE.TextureLoader();
    const btcTexture = loader.load(BITMAP);
    btcTexture.minFilter = THREE.LinearMipMapLinearFilter; // shimmer‑free scaling

    /** ---------- 4. Geometry ---------- **/
    // A. Central coin face (plane)
    const coin     = new THREE.Mesh(
        new THREE.PlaneGeometry(2, 2),
        new THREE.MeshStandardMaterial({map: btcTexture, transparent: true})
    );
    scene.add(coin);

    // B. Orbit ring (torus); colour sampled from Bitcoin orange
    const ringMat  = new THREE.MeshStandardMaterial({color: 0xf7931a, emissive: 0x000000});
    const ring     = new THREE.Mesh(
        new THREE.TorusGeometry(1.35, 0.06, 16, 100),
        ringMat
    );
    ring.rotation.x = Math.PI / 3.5;   // give it a tilt
    scene.add(ring);

    /** ---------- 5. Animation loop ---------- **/
    let t = 0;
    const animate = () => {
        t += 0.01;
        // Slow idle rotation
        ring.rotation.z += 0.005;
        coin.rotation.y = 0.15*Math.sin(t);

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    };

    /** ---------- 6. Interaction ---------- **/
    // Basic pointer‑driven rotation (no OrbitControls bloat)
    let isDown=false, lastX=0, lastY=0;
    const onPointerDown = e => {isDown = true; lastX = e.clientX; lastY = e.clientY;};
    const onPointerUp   = () => {isDown = false;};
    const onPointerMove = e => {
        if (!isDown) return;
        const dx = (e.clientX - lastX) * 0.01;
        const dy = (e.clientY - lastY) * 0.01;
        ring.rotation.y += dx;
        ring.rotation.x += dy;
        coin.rotation.y += dx;
        lastX = e.clientX; lastY = e.clientY;
    };
    canvas.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointerup',   onPointerUp);
    window.addEventListener('pointermove', onPointerMove);

    /** ---------- 7. Responsive sizing ---------- **/
    const onResize = () => {
        const {clientWidth:w, clientHeight:h} = canvas;
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
    };
    window.addEventListener('resize', onResize);
    onResize();

    animate();
})();
</script>
</body>
</html>
